// server/server.js - FIXED VERSION
import express from "express";
import cors from "cors";
import bodyParser from "body-parser";
import { Sequelize, DataTypes } from "sequelize";

const app = express();
const PORT = 8000;

// =======================
// Middleware - FIXED CORS
// =======================
app.use(cors({
  origin: [
    "http://localhost:3000", // Vite dev server default
    "http://localhost:3001", // Custom port n·∫øu c√≥
    "http://localhost:3002", // Additional port
    "http://127.0.0.1:3000",
    "http://127.0.0.1:3001",
    "http://127.0.0.1:3002",
    "http://127.0.0.1:3003"
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Request logging middleware
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [${req.method}] ${req.url} - IP: ${req.ip || req.connection.remoteAddress}`);
  next();
});

// =======================
// Database Connection - MySQL Configuration
// =======================
const sequelize = new Sequelize("training_management", "root", "123456", {
  host: "127.0.0.1",          // √©p d√πng TCP thay v√¨ socket
  port: 3306,
  dialect: "mysql",
  dialectOptions: {
    connectTimeout: 60000,    // timeout connect 60s
  },
  logging: (msg) => console.log(`[DB] ${msg}`),
  logging: console.log,
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000,
  }
});

// Test database connection
async function testConnection() {
  try {
    console.log("[DB] Attempting to connect to MySQL database...")
    await sequelize.authenticate();
    console.log("‚úÖ [DB] MySQL connection established successfully!");

    // await sequelize.sync({ force: true });
    // const [results] = await sequelize.query("DESCRIBE course_categories;");
    // console.log("üìã [DB] Fields in table course_categories:");
    // console.table(results);

    return true;
  } catch (error) {
    console.error("‚ùå [DB] MySQL connection failed:", error.message);
    return false;
  }
}

// Load sample data if tables are empty
async function loadSampleData() {
  try {
    console.log("[DB] Checking for sample data...");

    // Check if we already have data
    const departmentCount = await Department.count();
    if (departmentCount > 0) {
      console.log("[DB] Sample data already exists, skipping...");
      return;
    }

    console.log("[DB] Loading sample data...");

    // Create course categories
    const courseCategories = await CourseCategory.bulkCreate([
      { category_code: 'TECH', category_name: 'C√¥ng ngh·ªá th√¥ng tin', description: 'C√°c kh√≥a h·ªçc v·ªÅ c√¥ng ngh·ªá th√¥ng tin v√† l·∫≠p tr√¨nh' },
      { category_code: 'MANAGE', category_name: 'Qu·∫£n l√Ω', description: 'C√°c kh√≥a h·ªçc v·ªÅ k·ªπ nƒÉng qu·∫£n l√Ω v√† l√£nh ƒë·∫°o' },
      { category_code: 'SOFT', category_name: 'K·ªπ nƒÉng m·ªÅm', description: 'C√°c kh√≥a h·ªçc v·ªÅ k·ªπ nƒÉng giao ti·∫øp v√† l√†m vi·ªác nh√≥m' },
      { category_code: 'LANG', category_name: 'Ngo·∫°i ng·ªØ', description: 'C√°c kh√≥a h·ªçc v·ªÅ ngo·∫°i ng·ªØ' }
    ]);

    // Create departments
    const departments = await Department.bulkCreate([
      { department_code: 'IT', department_name: 'Ph√≤ng C√¥ng ngh·ªá th√¥ng tin', description: 'Ph√≤ng ph·ª• tr√°ch v·ªÅ c√¥ng ngh·ªá th√¥ng tin' },
      { department_code: 'HR', department_name: 'Ph√≤ng Nh√¢n s·ª±', description: 'Ph√≤ng ph·ª• tr√°ch v·ªÅ qu·∫£n l√Ω nh√¢n s·ª±' },
      { department_code: 'FIN', department_name: 'Ph√≤ng T√†i ch√≠nh', description: 'Ph√≤ng ph·ª• tr√°ch v·ªÅ t√†i ch√≠nh k·∫ø to√°n' },
      { department_code: 'MKT', department_name: 'Ph√≤ng Marketing', description: 'Ph√≤ng ph·ª• tr√°ch v·ªÅ marketing v√† b√°n h√†ng' }
    ]);

    // Create positions
    const positions = await Position.bulkCreate([
      { position_code: 'DEV', position_name: 'L·∫≠p tr√¨nh vi√™n', level: 3, description: 'Ph√°t tri·ªÉn ph·∫ßn m·ªÅm', department_id: 1 },
      { position_code: 'PM', position_name: 'Qu·∫£n l√Ω d·ª± √°n', level: 4, description: 'Qu·∫£n l√Ω c√°c d·ª± √°n c√¥ng ngh·ªá', department_id: 1 },
      { position_code: 'HR_MGR', position_name: 'Tr∆∞·ªüng ph√≤ng nh√¢n s·ª±', level: 5, description: 'Qu·∫£n l√Ω ph√≤ng nh√¢n s·ª±', department_id: 2 },
      { position_code: 'HR_SPEC', position_name: 'Chuy√™n vi√™n nh√¢n s·ª±', level: 3, description: 'Chuy√™n vi√™n ph·ª• tr√°ch nh√¢n s·ª±', department_id: 2 },
      { position_code: 'ACCOUNTANT', position_name: 'K·∫ø to√°n', level: 3, description: 'K·∫ø to√°n vi√™n', department_id: 3 },
      { position_code: 'MKT_MGR', position_name: 'Tr∆∞·ªüng ph√≤ng marketing', level: 5, description: 'Qu·∫£n l√Ω ph√≤ng marketing', department_id: 4 }
    ]);

    // Create employees
    const employees = await Employee.bulkCreate([
      { employee_code: 'EMP001', first_name: 'Nguy·ªÖn VƒÉn', last_name: 'An', email: 'an.nguyen@company.com', phone: '0123456789', position_id: 1, department_id: 1, hire_date: '2023-01-15', salary: 15000000 },
      { employee_code: 'EMP002', first_name: 'Tr·∫ßn Th·ªã', last_name: 'B√¨nh', email: 'binh.tran@company.com', phone: '0123456790', position_id: 2, department_id: 1, hire_date: '2022-06-01', salary: 20000000 },
      { employee_code: 'EMP003', first_name: 'L√™ VƒÉn', last_name: 'C∆∞·ªùng', email: 'cuong.le@company.com', phone: '0123456791', position_id: 3, department_id: 2, hire_date: '2021-03-10', salary: 25000000 },
      { employee_code: 'EMP004', first_name: 'Ph·∫°m Th·ªã', last_name: 'Dung', email: 'dung.pham@company.com', phone: '0123456792', position_id: 4, department_id: 2, hire_date: '2023-02-20', salary: 12000000 },
      { employee_code: 'EMP005', first_name: 'Ho√†ng VƒÉn', last_name: 'Em', email: 'em.hoang@company.com', phone: '0123456793', position_id: 5, department_id: 3, hire_date: '2022-11-05', salary: 13000000 },
      { employee_code: 'EMP006', first_name: 'V≈© Th·ªã', last_name: 'Ph∆∞∆°ng', email: 'phuong.vu@company.com', phone: '0123456794', position_id: 6, department_id: 4, hire_date: '2021-08-15', salary: 22000000 }
    ]);

    // Update department managers
    await Department.update({ manager_id: 2 }, { where: { id: 1 } });
    await Department.update({ manager_id: 3 }, { where: { id: 2 } });
    await Department.update({ manager_id: 5 }, { where: { id: 3 } });
    await Department.update({ manager_id: 6 }, { where: { id: 4 } });

    console.log("‚úÖ [DB] Sample data loaded successfully!");
  } catch (error) {
    console.error("‚ùå [DB] Failed to load sample data:", error.message);
  }
}

// =======================
// Models - ENHANCED WITH STATUS
// =======================
const Department = sequelize.define("Department", {
  department_code: {
    type: DataTypes.STRING(20),
    allowNull: false,
    unique: true,
    validate: {
      notEmpty: true,
      len: [1, 20]
    }
  },
  department_name: {
    type: DataTypes.STRING(100),
    allowNull: false,
    validate: {
      notEmpty: true,
      len: [1, 100]
    }
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  parent_department_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  manager_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
}, {
  tableName: "departments",
  timestamps: true,
  underscored: true
});

const Position = sequelize.define("Position", {
  position_code: {
    type: DataTypes.STRING(20),
    allowNull: false,
    unique: true
  },
  position_name: {
    type: DataTypes.STRING(100),
    allowNull: false
  },
  level: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  department_id: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
}, {
  tableName: "positions",
  timestamps: true,
  underscored: true
});

const Employee = sequelize.define("Employee", {
  employee_code: {
    type: DataTypes.STRING(20),
    allowNull: false,
    unique: true
  },
  first_name: {
    type: DataTypes.STRING(50),
    allowNull: false
  },
  last_name: {
    type: DataTypes.STRING(50),
    allowNull: false
  },
  email: {
    type: DataTypes.STRING(100),
    unique: true,
    allowNull: false,
    validate: {
      isEmail: true
    }
  },
  phone: {
    type: DataTypes.STRING(20)
  },
  address: {
    type: DataTypes.TEXT
  },
  date_of_birth: {
    type: DataTypes.DATEONLY
  },
  gender: {
    type: DataTypes.STRING(10),
    defaultValue: 'Other'
  },
  id_card: {
    type: DataTypes.STRING(20),
    unique: true
  },
  position_id: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  department_id: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  manager_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  hire_date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  salary: {
    type: DataTypes.DECIMAL(12, 2)
  },
  status: {
    type: DataTypes.STRING(20),
    defaultValue: 'Active'
  }
}, {
  tableName: "employees",
  timestamps: true,
  underscored: true
});

const CourseCategory = sequelize.define("CourseCategory", {
  category_code: {
    type: DataTypes.STRING(20),
    allowNull: false,
    validate: { notEmpty: true, len: [1, 20] },
  },

  // T√™n danh m·ª•c (NOT NULL)
  category_name: {
    type: DataTypes.STRING(255),
    allowNull: false,
    validate: { notEmpty: true, len: [1, 255] },
  },

  // M√¥ t·∫£
  description: {
    type: DataTypes.TEXT,
    allowNull: true,
  },

  // Tr·∫°ng th√°i ho·∫°t ƒë·ªông (b·∫£ng c·ªßa b·∫°n d√πng is_active BOOLEAN)
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
  },
}, {
  tableName: "course_categories",
  timestamps: true,
  underscored: true
});

const Course = sequelize.define("Course", {
  course_code: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  course_name: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  description: DataTypes.TEXT,
  category_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  duration_hours: DataTypes.INTEGER,
  total_credits: DataTypes.INTEGER,
  theory_credits: DataTypes.INTEGER,
  practice_credits: DataTypes.INTEGER,
  level: {
    type: DataTypes.STRING(50),
    defaultValue: 'Beginner'
  },
  prerequisite_course_ids: DataTypes.TEXT,
  concurrent_course_ids: DataTypes.TEXT,
  learning_objectives: DataTypes.TEXT,
  department_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  created_by: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  // status: {
  //   type: DataTypes.ENUM('draft', 'active', 'completed', 'cancelled'),
  //   defaultValue: 'draft'
  // }
}, {
  tableName: "courses",
  timestamps: true,
  underscored: true
});


const CourseSession = sequelize.define("CourseSession", {
  start_date: {
    type: DataTypes.DATE,
    allowNull: false
  },
  end_date: {
    type: DataTypes.DATE,
    allowNull: false
  },
  max_participants: {
    type: DataTypes.INTEGER,
    defaultValue: 30
  },
  status: {
    type: DataTypes.ENUM('scheduled', 'in_progress', 'completed', 'cancelled'),
    defaultValue: 'scheduled'
  }
}, {
  tableName: "course_sessions",
  timestamps: true,
  underscored: true
});

const Enrollment = sequelize.define("Enrollment", {
  status: {
    type: DataTypes.ENUM('pending', 'approved', 'rejected', 'completed'),
    defaultValue: "pending"
  },
  enrolled_date: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW
  }
}, {
  tableName: "enrollments",
  timestamps: true,
  underscored: true
});

const Cohort = sequelize.define("Cohort", {
  cohort_code: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  cohort_name: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  start_date: {
    type: DataTypes.DATEONLY,
    allowNull: false
  },
  end_date: {
    type: DataTypes.DATEONLY,
    allowNull: true
  },
  max_students: {
    type: DataTypes.INTEGER,
    defaultValue: 30
  },
  current_students: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  status: {
    type: DataTypes.ENUM('planning', 'active', 'completed', 'cancelled'),
    defaultValue: 'planning'
  },
  program_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  instructor_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  }
}, {
  tableName: "cohorts",
  timestamps: true,
  underscored: true
});

const Major = sequelize.define("Major", {
  major_code: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  major_name: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  degree_type: {
    type: DataTypes.ENUM('associate', 'bachelor', 'master', 'doctorate'),
    defaultValue: 'bachelor'
  },
  duration_years: {
    type: DataTypes.INTEGER,
    defaultValue: 4
  },
  total_credits: {
    type: DataTypes.INTEGER,
    defaultValue: 120
  },
  department_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  head_of_major_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
}, {
  tableName: "majors",
  timestamps: true,
  underscored: true
});

const KnowledgeBlock = sequelize.define("KnowledgeBlock", {
  block_code: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  block_name: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  total_credits: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  is_required: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  major_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
}, {
  tableName: "knowledge_blocks",
  timestamps: true,
  underscored: true
});

const CurriculumStructure = sequelize.define("CurriculumStructure", {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  program_id: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  major_id: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  knowledge_block_id: {
    type: DataTypes.INTEGER,
    allowNull: false
  },
  semester: {
    type: DataTypes.INTEGER,
    allowNull: true
  },
  is_required: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  min_credits: {
    type: DataTypes.INTEGER,
    defaultValue: 0
  },
  notes: {
    type: DataTypes.TEXT,
    allowNull: true
  }
}, {
  tableName: "curriculum_structures",
  timestamps: true,
  underscored: true
});

// Program model
const Program = sequelize.define("Program", {
  program_code: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  program_name: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  start_date: {
    type: DataTypes.DATEONLY,
    allowNull: true
  },
  end_date: {
    type: DataTypes.DATEONLY,
    allowNull: true
  },
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  }
}, {
  tableName: "programs",
  timestamps: true,
  underscored: true
});

// =======================
// Associations (FIXED)
// =======================

// Department ‚Äì Position ‚Äì Employee
Department.hasMany(Position, { foreignKey: 'department_id' });
Position.belongsTo(Department, { foreignKey: 'department_id' });

Department.hasMany(Employee, { foreignKey: 'department_id' });
Employee.belongsTo(Department, { foreignKey: 'department_id' });

Position.hasMany(Employee, { foreignKey: 'position_id' });
Employee.belongsTo(Position, { foreignKey: 'position_id' });

// Course relations
CourseCategory.hasMany(Course, { foreignKey: 'category_id' });
Course.belongsTo(CourseCategory, { foreignKey: 'category_id', as: 'CourseCategory' });
Course.belongsTo(Department, { foreignKey: 'department_id', as: 'Department' });
Course.belongsTo(Employee, { foreignKey: 'created_by', as: 'CreatedBy' });

Course.hasMany(CourseSession, { foreignKey: 'course_id' });
CourseSession.belongsTo(Course, { foreignKey: 'course_id' });

Employee.hasMany(Enrollment, { foreignKey: 'employee_id' });
Enrollment.belongsTo(Employee, { foreignKey: 'employee_id' });

CourseSession.hasMany(Enrollment, { foreignKey: 'course_session_id' });
Enrollment.belongsTo(CourseSession, { foreignKey: 'course_session_id' });

// Program ‚Äì Cohort ‚Äì Employee
Program.hasMany(Cohort, { foreignKey: 'program_id' });
Cohort.belongsTo(Program, { foreignKey: 'program_id', as: 'Program' });

Employee.hasMany(Cohort, { foreignKey: 'instructor_id' });
Cohort.belongsTo(Employee, { foreignKey: 'instructor_id', as: 'Instructor' });

Program.belongsToMany(KnowledgeBlock, { through: 'program_knowledge_blocks', foreignKey: 'program_id', otherKey: 'knowledge_block_id' });
KnowledgeBlock.belongsToMany(Program, { through: 'program_knowledge_blocks', foreignKey: 'knowledge_block_id', otherKey: 'program_id' });

// Department ‚Äì Major ‚Äì Employee
Department.hasMany(Major, { foreignKey: 'department_id' });
Major.belongsTo(Department, { foreignKey: 'department_id', as: 'Department' });

Employee.hasMany(Major, { foreignKey: 'head_of_major_id' });
Major.belongsTo(Employee, { foreignKey: 'head_of_major_id', as: 'HeadOfMajor' });

// Major ‚Äì KnowledgeBlock
Major.hasMany(KnowledgeBlock, { foreignKey: 'major_id', as: 'KnowledgeBlocks' });
KnowledgeBlock.belongsTo(Major, { foreignKey: 'major_id', as: 'Major' });

// ‚úÖ Program ‚Äì CurriculumStructure
Program.hasMany(CurriculumStructure, { foreignKey: 'program_id', as: 'CurriculumStructures' });
CurriculumStructure.belongsTo(Program, { foreignKey: 'program_id', as: 'Program' });

// ‚úÖ Major ‚Äì CurriculumStructure
Major.hasMany(CurriculumStructure, { foreignKey: 'major_id', as: 'CurriculumStructures' });
CurriculumStructure.belongsTo(Major, { foreignKey: 'major_id', as: 'Major' });

// ‚úÖ KnowledgeBlock ‚Äì CurriculumStructure
KnowledgeBlock.hasMany(CurriculumStructure, { foreignKey: 'knowledge_block_id', as: 'CurriculumStructures' });
CurriculumStructure.belongsTo(KnowledgeBlock, { foreignKey: 'knowledge_block_id', as: 'KnowledgeBlock' });

CurriculumStructure.associate = (models) => {
  CurriculumStructure.belongsTo(models.Program, { foreignKey: 'program_id' });
  CurriculumStructure.belongsTo(models.Major, { foreignKey: 'major_id' });
  CurriculumStructure.belongsTo(models.KnowledgeBlock, { foreignKey: 'knowledge_block_id' });
};
// =======================
// Helper function to handle errors
// =======================
const handleError = (res, error, defaultMessage = "Internal server error") => {
  const timestamp = new Date().toISOString();
  console.error(`[${timestamp}] [API Error] ${error.name}:`, error.message);

  if (error.name === 'SequelizeValidationError') {
    return res.status(400).json({
      error: error.errors.map(e => e.message).join(', ')
    });
  }

  if (error.name === 'SequelizeUniqueConstraintError') {
    return res.status(400).json({
      error: "D·ªØ li·ªáu ƒë√£ t·ªìn t·∫°i"
    });
  }

  res.status(500).json({
    error: error.message || defaultMessage
  });
};

// =======================
// API Routes - ENHANCED WITH BETTER ERROR HANDLING
// =======================

// Health check endpoint
app.get("/api/health", (req, res) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [HEALTH] Health check requested`);

  res.json({
    success: true,
    message: "Server is running",
    timestamp,
    database: sequelize.connectionManager.pool ? "connected" : "disconnected"
  });
});

// ---- Departments ----
app.get("/api/departments", async (req, res) => {
  try {
    const departments = await Department.findAll({
      order: [['created_at', 'DESC']]
    });
    res.json(departments);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch ph√≤ng ban");
  }
});

app.get("/api/departments/:id", async (req, res) => {
  try {
    const department = await Department.findByPk(req.params.id);
    if (!department) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ph√≤ng ban" });
    }
    res.json(department);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th√¥ng tin ph√≤ng ban");
  }
});

app.post("/api/departments", async (req, res) => {
  try {
    const { department_code, department_name, description, parent_department_id, manager_id, is_active = true } = req.body;

    console.log(req.body);

    if (!department_code || !department_name) {
      return res.status(400).json({
        error: "M√£ ph√≤ng ban v√† t√™n ph√≤ng ban l√† b·∫Øt bu·ªôc"
      });
    }

    // Convert empty strings to null for integer fields
    const cleanParentDepartmentId = parent_department_id === '' ? null : parent_department_id;
    const cleanManagerId = manager_id === '' ? null : manager_id;

    const department = await Department.create({
      department_code,
      department_name,
      description,
      parent_department_id: cleanParentDepartmentId,
      manager_id: cleanManagerId,
      is_active
    });

    res.status(201).json(department);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m ph√≤ng ban");
  }
});

app.put("/api/departments/:id", async (req, res) => {
  try {
    const department = await Department.findByPk(req.params.id);
    if (!department) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ph√≤ng ban" });
    }

    // Convert empty strings to null for integer fields
    const updateData = { ...req.body };
    if (updateData.parent_department_id === '') {
      updateData.parent_department_id = null;
    }
    if (updateData.manager_id === '') {
      updateData.manager_id = null;
    }

    await department.update(updateData);
    res.json(department);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ph√≤ng ban");
  }
});

app.delete("/api/departments/:id", async (req, res) => {
  try {
    const department = await Department.findByPk(req.params.id);
    if (!department) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ph√≤ng ban" });
    }

    // Check if department has employees
    const employeeCount = await Employee.count({
      where: { department_id: req.params.id }
    });

    if (employeeCount > 0) {
      return res.status(400).json({
        error: "Kh√¥ng th·ªÉ x√≥a ph√≤ng ban c√≥ nh√¢n vi√™n"
      });
    }

    await department.destroy();
    res.json({ message: "X√≥a ph√≤ng ban th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a ph√≤ng ban");
  }
});

// ---- Positions ---- (Similar pattern for other endpoints)
app.get("/api/positions", async (req, res) => {
  try {
    const positions = await Position.findAll({
      include: [{
        model: Department,
        attributes: ['id', 'department_name', 'department_code']
      }],
      order: [['created_at', 'DESC']]
    });
    res.json(positions);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch ch·ª©c v·ª•");
  }
});

app.post("/api/positions", async (req, res) => {
  try {
    const { position_code, position_name, level, description, department_id, is_active = true } = req.body;

    // Convert empty string to null for department_id
    const cleanDepartmentId = department_id === '' ? null : department_id;

    if (!position_code || !position_name || !cleanDepartmentId) {
      return res.status(400).json({
        error: "M√£ ch·ª©c v·ª•, t√™n ch·ª©c v·ª• v√† ph√≤ng ban l√† b·∫Øt bu·ªôc"
      });
    }

    const position = await Position.create({
      position_code,
      position_name,
      level,
      description,
      department_id: cleanDepartmentId,
      is_active
    });

    res.status(201).json(position);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m ch·ª©c v·ª•");
  }
});

app.put("/api/positions/:id", async (req, res) => {
  try {
    const position = await Position.findByPk(req.params.id);
    if (!position) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ch·ª©c v·ª•" });
    }
    await position.update(req.body);
    res.json(position);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ch·ª©c v·ª•");
  }
});

app.delete("/api/positions/:id", async (req, res) => {
  try {
    const position = await Position.findByPk(req.params.id);
    if (!position) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ch·ª©c v·ª•" });
    }
    await position.destroy();
    res.json({ message: "X√≥a ch·ª©c v·ª• th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a ch·ª©c v·ª•");
  }
});

app.post("/api/courses", async (req, res) => {
  try {
    let {
      course_code, course_name, description, category_id,
      duration_hours, total_credits, theory_credits, practice_credits, level,
      prerequisite_course_ids, concurrent_course_ids, learning_objectives,
      department_id, created_by, is_active = true
    } = req.body;

    if (!course_code || !course_name) {
      return res.status(400).json({ error: "M√£ h·ªçc ph·∫ßn v√† t√™n h·ªçc ph·∫ßn l√† b·∫Øt bu·ªôc" });
    }

    // N·∫øu frontend g·ª≠i "" th√¨ convert th√†nh null
    if (category_id === "" || category_id === undefined) category_id = null;
    if (department_id === "" || department_id === undefined) department_id = null;
    if (created_by === "" || created_by === undefined) created_by = null;

    const course = await Course.create({
      course_code,
      course_name,
      description,
      category_id,
      duration_hours,
      total_credits,
      theory_credits,
      practice_credits,
      level,
      prerequisite_course_ids,
      concurrent_course_ids,
      learning_objectives,
      department_id,
      created_by,
      is_active
    });

    res.status(201).json(course);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m h·ªçc ph·∫ßn");
  }
});


app.get("/api/courses", async (req, res) => {
  try {
    const courses = await Course.findAll({
      include: [
        { model: CourseCategory, as: "CourseCategory", required: false, attributes: ["id", "category_name"] },
        { model: Department, as: "Department", required: false, attributes: ["id", "department_name"] },
        { model: Employee, as: "CreatedBy", required: false, attributes: ["id", "first_name", "last_name"] }
      ],
      order: [["created_at", "DESC"]]
    });
    res.json(courses);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch h·ªçc ph·∫ßn");
  }
});

// C·∫≠p nh·∫≠t h·ªçc ph·∫ßn
app.put("/api/courses/:id", async (req, res) => {
  try {
    const course = await Course.findByPk(req.params.id);
    if (!course) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y h·ªçc ph·∫ßn" });
    }

    // Ch·ªâ cho ph√©p update nh·ªØng field h·ª£p l·ªá
    const allowedFields = [
      "course_name",
      "description",
      "category_id",
      "duration_hours",
      "total_credits",
      "theory_credits",
      "practice_credits",
      "level",
      "prerequisite_course_ids",
      "concurrent_course_ids",
      "learning_objectives",
      "department_id",
      "is_active"
    ];

    await course.update(req.body, { fields: allowedFields });
    res.json(course);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t h·ªçc ph·∫ßn");
  }
});

// X√≥a h·ªçc ph·∫ßn
app.delete("/api/courses/:id", async (req, res) => {
  try {
    const course = await Course.findByPk(req.params.id);
    if (!course) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y h·ªçc ph·∫ßn" });
    }

    await course.destroy();
    res.json({ message: "X√≥a h·ªçc ph·∫ßn th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a h·ªçc ph·∫ßn");
  }
});

app.get("/api/course-categories", async (req, res) => {
  try {
    const categories = await CourseCategory.findAll({
      order: [["created_at", "DESC"]],
    });
    res.json(categories);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch danh m·ª•c h·ªçc ph·∫ßn");
  }
});

// GET 1 course category by id
app.get("/api/course-categories/:id", async (req, res) => {
  try {
    const category = await CourseCategory.findByPk(req.params.id);
    if (!category) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y danh m·ª•c h·ªçc ph·∫ßn" });
    }
    res.json(category);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th√¥ng tin danh m·ª•c h·ªçc ph·∫ßn");
  }
});

// ---- Employees ----
app.get("/api/employees", async (req, res) => {
  try {
    const employees = await Employee.findAll({
      include: [
        {
          model: Department,
          attributes: ['id', 'department_name', 'department_code']
        },
        {
          model: Position,
          attributes: ['id', 'position_name', 'position_code', 'level']
        }
      ],
      order: [['created_at', 'DESC']]
    });
    res.json(employees);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch nh√¢n vi√™n");
  }
});

app.get("/api/employees/:id", async (req, res) => {
  try {
    const employee = await Employee.findByPk(req.params.id, {
      include: [
        {
          model: Department,
          attributes: ['id', 'department_name', 'department_code']
        },
        {
          model: Position,
          attributes: ['id', 'position_name', 'position_code', 'level']
        }
      ]
    });
    if (!employee) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n" });
    }
    res.json(employee);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th√¥ng tin nh√¢n vi√™n");
  }
});

app.post("/api/employees", async (req, res) => {
  try {
    const {
      employee_code, first_name, last_name, email, phone, address,
      date_of_birth, gender, id_card, position_id, department_id,
      manager_id, hire_date, salary, status = 'Active'
    } = req.body;

    if (!employee_code || !first_name || !last_name || !email || !position_id || !department_id || !hire_date) {
      return res.status(400).json({
        error: "M√£ nh√¢n vi√™n, h·ªç t√™n, email, ch·ª©c v·ª•, ph√≤ng ban v√† ng√†y tuy·ªÉn d·ª•ng l√† b·∫Øt bu·ªôc"
      });
    }

    // Convert empty strings to null for optional fields
    const cleanManagerId = manager_id === '' ? null : manager_id;
    const cleanIdCard = id_card === '' ? null : id_card;
    const cleanAddress = address === '' ? null : address;
    const cleanPhone = phone === '' ? null : phone;

    const employee = await Employee.create({
      employee_code,
      first_name,
      last_name,
      email,
      phone: cleanPhone,
      address: cleanAddress,
      date_of_birth,
      gender,
      id_card: cleanIdCard,
      position_id,
      department_id,
      manager_id: cleanManagerId,
      hire_date,
      salary,
      status
    });

    res.status(201).json(employee);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m nh√¢n vi√™n");
  }
});

app.put("/api/employees/:id", async (req, res) => {
  try {
    const employee = await Employee.findByPk(req.params.id);
    if (!employee) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n" });
    }

    // Convert empty strings to null for optional fields
    const updateData = { ...req.body };
    if (updateData.manager_id === '') {
      updateData.manager_id = null;
    }
    if (updateData.id_card === '') {
      updateData.id_card = null;
    }
    if (updateData.address === '') {
      updateData.address = null;
    }
    if (updateData.phone === '') {
      updateData.phone = null;
    }

    await employee.update(updateData);
    res.json(employee);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t nh√¢n vi√™n");
  }
});

app.delete("/api/employees/:id", async (req, res) => {
  try {
    const employee = await Employee.findByPk(req.params.id);
    if (!employee) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n" });
    }

    await employee.destroy();
    res.json({ message: "X√≥a nh√¢n vi√™n th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a nh√¢n vi√™n");
  }
});

// ---- Curriculum Structure ----
app.get("/api/curriculum-structure", async (req, res) => {
  try {
    const structures = await CurriculumStructure.findAll({
      include: [
        { model: Major, as: 'Major', attributes: ['id', 'major_name', 'major_code'] },
        { model: KnowledgeBlock, as: 'KnowledgeBlock', attributes: ['id', 'block_name', 'block_code'] }
      ],
      order: [['major_id', 'ASC'], ['semester', 'ASC']]
    });
    res.json(structures);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i c·∫•u tr√∫c CTƒêT");
  }
});

app.post("/api/curriculum-structure", async (req, res) => {
  try {
    const { major_id, knowledge_block_id, semester, is_required = true, min_credits = 0, notes } = req.body;
    if (!major_id || !knowledge_block_id) {
      return res.status(400).json({ error: "Ng√†nh h·ªçc v√† kh·ªëi ki·∫øn th·ª©c l√† b·∫Øt bu·ªôc" });
    }
    const structure = await CurriculumStructure.create({ major_id, knowledge_block_id, semester, is_required, min_credits, notes: notes || null });
    res.status(201).json(structure);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m c·∫•u tr√∫c");
  }
});

app.put("/api/curriculum-structure/:id", async (req, res) => {
  try {
    const structure = await CurriculumStructure.findByPk(req.params.id);
    if (!structure) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y c·∫•u tr√∫c" });
    await structure.update(req.body);
    res.json(structure);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t c·∫•u tr√∫c");
  }
});

app.delete("/api/curriculum-structure/:id", async (req, res) => {
  try {
    const structure = await CurriculumStructure.findByPk(req.params.id);
    if (!structure) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y c·∫•u tr√∫c" });
    await structure.destroy();
    res.json({ message: "X√≥a th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a c·∫•u tr√∫c");
  }
});

// ---- Knowledge Blocks ----
app.get("/api/knowledge-blocks", async (req, res) => {
  try {
    const blocks = await KnowledgeBlock.findAll({
      include: [{ model: Major, as: 'Major', attributes: ['id', 'major_name', 'major_code'] }],
      order: [['created_at', 'DESC']]
    });
    res.json(blocks);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch kh·ªëi ki·∫øn th·ª©c");
  }
});

app.post("/api/knowledge-blocks", async (req, res) => {
  try {
    const { block_code, block_name, description, total_credits = 0, is_required = true, major_id, is_active = true } = req.body;
    if (!block_code || !block_name) {
      return res.status(400).json({ error: "M√£ kh·ªëi v√† t√™n kh·ªëi l√† b·∫Øt bu·ªôc" });
    }
    const block = await KnowledgeBlock.create({
      block_code, block_name, description: description || null,
      total_credits, is_required, major_id: major_id || null, is_active
    });
    res.status(201).json(block);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m kh·ªëi ki·∫øn th·ª©c");
  }
});

app.put("/api/knowledge-blocks/:id", async (req, res) => {
  try {
    const block = await KnowledgeBlock.findByPk(req.params.id);
    if (!block) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y kh·ªëi ki·∫øn th·ª©c" });
    await block.update(req.body);
    res.json(block);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t kh·ªëi ki·∫øn th·ª©c");
  }
});

app.delete("/api/knowledge-blocks/:id", async (req, res) => {
  try {
    const block = await KnowledgeBlock.findByPk(req.params.id);
    if (!block) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y kh·ªëi ki·∫øn th·ª©c" });
    await block.destroy();
    res.json({ message: "X√≥a kh·ªëi ki·∫øn th·ª©c th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a kh·ªëi ki·∫øn th·ª©c");
  }
});

// ---- Majors ----
app.get("/api/majors", async (req, res) => {
  try {
    const majors = await Major.findAll({
      include: [
        {
          model: Department,
          as: 'Department',
          attributes: ['id', 'department_name', 'department_code']
        },
        {
          model: Employee,
          as: 'HeadOfMajor',
          attributes: ['id', 'first_name', 'last_name', 'email']
        }
      ],
      order: [['created_at', 'DESC']]
    });
    res.json(majors);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch ng√†nh h·ªçc");
  }
});

app.get("/api/majors/:id", async (req, res) => {
  try {
    const major = await Major.findByPk(req.params.id, {
      include: [
        {
          model: Department,
          as: 'Department',
          attributes: ['id', 'department_name', 'department_code']
        },
        {
          model: Employee,
          as: 'HeadOfMajor',
          attributes: ['id', 'first_name', 'last_name', 'email']
        }
      ]
    });
    if (!major) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ng√†nh h·ªçc" });
    }
    res.json(major);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th√¥ng tin ng√†nh h·ªçc");
  }
});

app.post("/api/majors", async (req, res) => {
  try {
    const {
      major_code, major_name, description, degree_type = 'bachelor',
      duration_years = 4, total_credits = 120, department_id,
      head_of_major_id, is_active = true
    } = req.body;

    if (!major_code || !major_name) {
      return res.status(400).json({
        error: "M√£ ng√†nh h·ªçc v√† t√™n ng√†nh h·ªçc l√† b·∫Øt bu·ªôc"
      });
    }

    // Convert empty strings to null for optional fields
    const cleanDepartmentId = department_id === '' ? null : department_id;
    const cleanHeadOfMajorId = head_of_major_id === '' ? null : head_of_major_id;
    const cleanDescription = description === '' ? null : description;

    const major = await Major.create({
      major_code,
      major_name,
      description: cleanDescription,
      degree_type,
      duration_years,
      total_credits,
      department_id: cleanDepartmentId,
      head_of_major_id: cleanHeadOfMajorId,
      is_active
    });

    res.status(201).json(major);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m ng√†nh h·ªçc");
  }
});

app.put("/api/majors/:id", async (req, res) => {
  try {
    const major = await Major.findByPk(req.params.id);
    if (!major) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ng√†nh h·ªçc" });
    }

    // Convert empty strings to null for optional fields
    const updateData = { ...req.body };
    if (updateData.department_id === '') {
      updateData.department_id = null;
    }
    if (updateData.head_of_major_id === '') {
      updateData.head_of_major_id = null;
    }
    if (updateData.description === '') {
      updateData.description = null;
    }

    await major.update(updateData);
    res.json(major);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ng√†nh h·ªçc");
  }
});

app.delete("/api/majors/:id", async (req, res) => {
  try {
    const major = await Major.findByPk(req.params.id);
    if (!major) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ng√†nh h·ªçc" });
    }

    await major.destroy();
    res.json({ message: "X√≥a ng√†nh h·ªçc th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a ng√†nh h·ªçc");
  }
});

// ---- Programs ----
app.get("/api/programs", async (req, res) => {
  try {
    const programs = await Program.findAll({
      include: [
        {
          model: KnowledgeBlock,
          attributes: ["id", "block_code", "block_name", "total_credits", "is_required", "is_active"],
        },
      ],
      order: [["created_at", "DESC"]],
    });
    res.json(programs);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch ch∆∞∆°ng tr√¨nh");
  }
});

app.get("/api/programs/:id", async (req, res) => {
  try {
    const program = await Program.findByPk(req.params.id, {
      include: [
        {
          model: KnowledgeBlock,
          attributes: ["id", "block_code", "block_name", "total_credits", "is_required", "is_active"],
        },
      ],
    });
    if (!program) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng tr√¨nh" });
    }
    res.json(program);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th√¥ng tin ch∆∞∆°ng tr√¨nh");
  }
});

app.post("/api/programs", async (req, res) => {
  try {
    const { program_code, program_name, description, start_date, end_date, is_active = true, knowledge_block_ids } = req.body;

    if (!program_code || !program_name) {
      return res.status(400).json({ error: "M√£ ch∆∞∆°ng tr√¨nh v√† t√™n ch∆∞∆°ng tr√¨nh l√† b·∫Øt bu·ªôc" });
    }

    const program = await Program.create({
      program_code,
      program_name,
      description: description === '' ? null : description,
      start_date: start_date === '' ? null : start_date,
      end_date: end_date === '' ? null : end_date,
      is_active
    });

    // Link knowledge blocks if provided
    if (Array.isArray(knowledge_block_ids) && knowledge_block_ids.length > 0) {
      await program.setKnowledgeBlocks(knowledge_block_ids);
    }

    res.status(201).json(program);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m ch∆∞∆°ng tr√¨nh");
  }
});

app.put("/api/programs/:id", async (req, res) => {
  try {
    const program = await Program.findByPk(req.params.id);
    if (!program) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng tr√¨nh" });
    }

    const updateData = { ...req.body };
    if (updateData.description === '') updateData.description = null;
    if (updateData.start_date === '') updateData.start_date = null;
    if (updateData.end_date === '') updateData.end_date = null;

    await program.update(updateData);

    // Link knowledge blocks if provided
    if (Array.isArray(req.body.knowledge_block_ids)) {
      await program.setKnowledgeBlocks(req.body.knowledge_block_ids);
    }

    res.json(program);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ch∆∞∆°ng tr√¨nh");
  }
});

app.delete("/api/programs/:id", async (req, res) => {
  try {
    const program = await Program.findByPk(req.params.id);
    if (!program) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ch∆∞∆°ng tr√¨nh" });
    }
    await program.destroy();
    res.json({ message: "X√≥a ch∆∞∆°ng tr√¨nh th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a ch∆∞∆°ng tr√¨nh");
  }
});

// ---- Cohorts ----
app.get("/api/cohorts", async (req, res) => {
  try {
    const cohorts = await Cohort.findAll({
      include: [
        {
          model: Program,
          as: 'Program',
          attributes: ['id', 'program_code', 'program_name']
        },
        {
          model: Employee,
          as: 'Instructor',
          attributes: ['id', 'first_name', 'last_name', 'email']
        }
      ],
      order: [['created_at', 'DESC']]
    });
    res.json(cohorts);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i danh s√°ch l·ªõp h·ªçc");
  }
});

app.get("/api/cohorts/:id", async (req, res) => {
  try {
    const cohort = await Cohort.findByPk(req.params.id, {
      include: [
        {
          model: Program,
          as: 'Program',
          attributes: ['id', 'program_code', 'program_name']
        },
        {
          model: Employee,
          as: 'Instructor',
          attributes: ['id', 'first_name', 'last_name', 'email']
        }
      ]
    });
    if (!cohort) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y l·ªõp h·ªçc" });
    }
    res.json(cohort);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th√¥ng tin l·ªõp h·ªçc");
  }
});

app.post("/api/cohorts", async (req, res) => {
  try {
    const {
      cohort_code, cohort_name, description, start_date, end_date,
      max_students = 30, current_students = 0, status = 'planning',
      program_id, instructor_id
    } = req.body;

    if (!cohort_code || !cohort_name || !start_date) {
      return res.status(400).json({
        error: "M√£ l·ªõp h·ªçc, t√™n l·ªõp h·ªçc v√† ng√†y b·∫Øt ƒë·∫ßu l√† b·∫Øt bu·ªôc"
      });
    }

    // Convert empty strings to null for optional fields
    const cleanProgramId = program_id === '' ? null : program_id;
    const cleanInstructorId = instructor_id === '' ? null : instructor_id;
    const cleanEndDate = end_date === '' ? null : end_date;
    const cleanDescription = description === '' ? null : description;

    const cohort = await Cohort.create({
      cohort_code,
      cohort_name,
      description: cleanDescription,
      start_date,
      end_date: cleanEndDate,
      max_students,
      current_students,
      status,
      program_id: cleanProgramId,
      instructor_id: cleanInstructorId
    });

    res.status(201).json(cohort);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ th√™m l·ªõp h·ªçc");
  }
});

app.put("/api/cohorts/:id", async (req, res) => {
  try {
    const cohort = await Cohort.findByPk(req.params.id);
    if (!cohort) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y l·ªõp h·ªçc" });
    }

    // Convert empty strings to null for optional fields
    const updateData = { ...req.body };
    if (updateData.program_id === '') {
      updateData.program_id = null;
    }
    if (updateData.instructor_id === '') {
      updateData.instructor_id = null;
    }
    if (updateData.end_date === '') {
      updateData.end_date = null;
    }
    if (updateData.description === '') {
      updateData.description = null;
    }

    await cohort.update(updateData);
    res.json(cohort);
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t l·ªõp h·ªçc");
  }
});

app.delete("/api/cohorts/:id", async (req, res) => {
  try {
    const cohort = await Cohort.findByPk(req.params.id);
    if (!cohort) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y l·ªõp h·ªçc" });
    }

    await cohort.destroy();
    res.json({ message: "X√≥a l·ªõp h·ªçc th√†nh c√¥ng" });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ x√≥a l·ªõp h·ªçc");
  }
});

// =======================
// API: Curriculum Viewer (FIXED)
// =======================
app.get("/api/curriculum-viewer/full", async (req, res) => {
  try {
    // Get all programs with their linked knowledge blocks and each block's courses
    const programs = await Program.findAll({
      include: [
        {
          model: KnowledgeBlock,
          through: { attributes: [] }, // hide join table
          attributes: ["id", "block_code", "block_name", "total_credits"],
          include: [
            {
              model: Course,
              as: "Courses",
              attributes: ["id", "course_code", "course_name", "total_credits", "duration_hours", "level"]
            }
          ]
        }
      ],
      order: [["created_at", "DESC"]],
    });
    if (!programs.length) {
      return res.status(404).json({ message: "Kh√¥ng c√≥ ch∆∞∆°ng tr√¨nh ƒë√†o t·∫°o n√†o." });
    }
    res.json({
      success: true,
      count: programs.length,
      data: programs,
    });
  } catch (error) {
    console.error("‚ùå Curriculum Viewer API Error:", error);
    res.status(500).json({ message: "Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu hi·ªÉn th·ªã CTƒêT", error: error.message });
  }
});

// ---- Dashboard ----
app.get("/api/dashboard/stats", async (req, res) => {
  try {
    const [
      totalEmployees, totalDepartments, totalCourses, totalEnrollments,
      totalMajors, totalCohorts, totalKnowledgeBlocks, totalPositions,
      activeEmployees, activeCohorts, completedCohorts
    ] = await Promise.all([
      Employee.count(),
      Department.count(),
      Course.count(),
      Enrollment.count(),
      Major.count(),
      Cohort.count(),
      KnowledgeBlock.count(),
      Position.count(),
      Employee.count({ where: { status: 'Active' } }),
      Cohort.count({ where: { status: 'active' } }),
      Cohort.count({ where: { status: 'completed' } })
    ]);

    res.json({
      totalEmployees,
      totalDepartments,
      totalCourses,
      totalEnrollments,
      totalMajors,
      totalCohorts,
      totalKnowledgeBlocks,
      totalPositions,
      activeEmployees,
      activeCohorts,
      completedCohorts
    });
  } catch (error) {
    handleError(res, error, "Kh√¥ng th·ªÉ t·∫£i th·ªëng k√™ dashboard");
  }
});

// =======================
// Initialize and start server
// =======================
async function initializeServer() {
  console.log("[SERVER] Initializing server...");
  const isConnected = await testConnection();
  if (!isConnected) {
    console.error("‚ùå [SERVER] Cannot start server due to database connection failure");
    process.exit(1);
  }

  try {
    console.log("[DB] Syncing database tables...");
    await sequelize.sync(); // N·∫øu c·∫ßn l√†m s·∫°ch, d√πng { force: true }
    console.log("‚úÖ [DB] Database tables synced successfully");

    await loadSampleData();

    app.listen(PORT, () => {
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] üöÄ Server started successfully at http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error("‚ùå [SERVER] Server startup failed:", error.message);
    process.exit(1);
  }
}

initializeServer();